# Testing

## How to run tests

Run unit tests with:

```bash
poetry run invoke test
```

Generate a html coverage report by:

```bash
poetry run invoke coverage-report
```

Coverage report will be generate in html format to the folder "htmlcov" located under project root.

Run lint by:

```bash
poetry run invoke lint
```

Tests on TrieTree and ShakuGenerator -classes are important since all of the complicated logic is located in those classes.

## TrieTree tests

The tests on TrieTree class verify the general usage of the class and its functions for generating the trie data structure implementation based on the training data. Even though the integers fed to the tests are corresponding to regular shakuhachi pitch integers, the trie tree implementation has no dependency on the range of the provided integers, and as such, could be filled with any type of sequence, including sequences containing data other than integers. (although method argument type annotations might need to be edited)

## ShakuGenerator tests

Besides verifying the program's functionality by giving class methods different outputs, the tests on the ShakuGenerator class also provide verification on the algorithms functionality being as desired.
(it is quite hard to verify from generated music alone how it is generated, so the tests aim to provide proof that the generated music is in fact based on the sequences in the training data)

As such, some tests include generating a defined trie structure so as to avoid accidental passing / failing, and to provide a way to compare the output to the input. This defined trie structure is generated by the method "_make_defined_trie", which fills the two trie trees (pitch and lenght) with three different sets of base data, each used by separate tests, noting in their docstrings which set they utilize. By reading these tests, it should be apparent that the generated notes in the application are in fact based on the training data.

The tests utilize the pitch trie and the lenght trie input is coincidental - required by the shakugenerator class, but not utilized for the tests. The tests could be changed to utilize the lenght trie, but the result would be identical, as the lenght trie is not coded as a separate class and is never handled by any part of the application in a different manner to the pitch trie.

The time complexity of the program for generating note sequences being limited to O(n) is verified by the "test_generate_note_time_complexity" test case, by running the algorithm with  

## Interfaces tests

The test case "test_run_generates_correct_lenght_of_music" is designed to verify that the application produces the required lenght of output

## Coverage Report

<img src="https://github.com/ElectricShakuhachi/tiralabra-shakugenerator/blob/main/documentation/coverage.png" width="780">

The code coverage of some classes is quite low, but those are classes with very limited complexity.

## Time Complexity

The time complexity of music sequence generation is O(n), as illustrated with this chart, generated with "test_generate_note_time_complexity" test in unittests for ShakuGenerator class:

<img src="https://github.com/ElectricShakuhachi/tiralabra-shakugenerator/blob/main/documentation/generation_time_complexity_stats.png" width="560">


The time complexity of training the trie tree is also O(n), as illustrated with this chart, similarly created with the "test_feed_data_time_complexity" test case in unittests for TrieTree class:

<img src="https://github.com/ElectricShakuhachi/tiralabra-shakugenerator/blob/main/documentation/trie_population_time_stats.png" width="560">

The data generated in these test cases was written to a file, and copied to a chart for this representation. The fact that the statistics show that the program takes a slightly longer time to generate just one note rather than two is probably due to the fact that the trie class generates the first note randomly, and the pseudo-random number function or parts of the code surrounding it take more time than generating the subsequent notes according to the core algorithm. Another possibility for this is some caching making the subsequent runs slightly faster.
